<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploring Request Interceptors</title>
    <link rel="stylesheet" href="/css/style.css">
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <header>
        <!-- Partial: header.ejs -->
<div>
    <h1 class="Title-Effects"> <a href="/"> TheSaturdayProjects </a>
    <nav>
        <a href="/">Home</a>
        <a href="/Projects">Projects</a>
        <a target="_blank" rel="noopener" href="https://github.com/vijayanathan23">Guess Who?</a>
    </nav>
</h1>
<link rel="icon" type="image/x-icon" href="/favicon.ico">
</div>
    </header>

    <main class="main-container">
        <article class="post">
    <h1 style="text-align: center;">Exploring Request Interceptors</h1>
    <div class="post-content">
        <h1 id="Understanding-Interceptors"><a href="#Understanding-Interceptors" class="headerlink" title="Understanding Interceptors"></a>Understanding Interceptors</h1><p>Interceptors are essential tools for monitoring and analyzing network communication, allowing cybersecurity professionals to observe how two or more computers interact. By capturing and inspecting network traffic, interceptors help in debugging, security testing, and performance analysis.  </p>
<p>Interception primarily happens at two key levels: <strong>Application Layer</strong> and <strong>Network Layer</strong>.  </p>
<h2 id="Application-Layer-Interception"><a href="#Application-Layer-Interception" class="headerlink" title="Application Layer Interception"></a>Application Layer Interception</h2><p>At the <strong>Application Layer</strong>, interception is commonly used to analyze and test <strong>HTTP&#x2F;HTTPS</strong> protocols and <strong>socket communication</strong>. This helps in debugging APIs, security testing, and understanding request&#x2F;response flows.  </p>
<p>Popular tools for application-layer interception include:  </p>
<ul>
<li><strong>Burp Suite</strong> – A powerful tool for web security testing.  </li>
<li><strong>ZAP (Zed Attack Proxy)</strong> – An open-source security scanner, widely used for penetration testing.  </li>
<li><strong>MITMproxy</strong> – A tool specifically designed for intercepting, modifying, and analyzing HTTP&#x2F;HTTPS traffic.</li>
</ul>
<h2 id="Network-Layer-Interception"><a href="#Network-Layer-Interception" class="headerlink" title="Network Layer Interception"></a>Network Layer Interception</h2><p>At the <strong>Network Layer</strong>, interception is focused on capturing and analyzing raw network traffic at a lower level. This helps in identifying vulnerabilities, tracking network behavior, and diagnosing issues.<br>Key tools for network-layer interception include:  </p>
<ul>
<li><strong>Wireshark</strong> – A widely used packet sniffer for deep network traffic analysis.  </li>
<li><strong>tcpdump</strong> – A command-line network packet analyzer for capturing and inspecting traffic in real time.</li>
</ul>
<hr>
<h2 id="This-Saturday’s-Exploration"><a href="#This-Saturday’s-Exploration" class="headerlink" title="This Saturday’s Exploration"></a>This Saturday’s Exploration</h2><p>Now, as this Saturday’s exploration plan is to understand how <strong>Web Application Interception</strong> works and maybe build a small one?<br>(Well, we have a lot of <strong>LLMs 🤖</strong> for help… [just for help XD])</p>
<p>Having used <strong>Burp Suite</strong> (a tool used for request interception) a few years back, I am familiar with the <strong>Proxy server concept</strong>.</p>
<hr>
<h2 id="Interceptors-vs-Proxies-What’s-the-Difference"><a href="#Interceptors-vs-Proxies-What’s-the-Difference" class="headerlink" title="Interceptors vs. Proxies: What’s the Difference?"></a>Interceptors vs. Proxies: What’s the Difference?</h2><p>A <strong>proxy server</strong> acts as an intermediary that forwards requests and responses between a client (browser) and a server.<br>Proxies can serve various purposes, including <strong>caching, security, filtering, and anonymity</strong>—not just interception.  </p>
<p>On the other hand, an <strong>interceptor</strong> is a specialized proxy that focuses on <strong>monitoring and analyzing</strong> network traffic.<br>It captures, logs, and sometimes modifies requests and responses.  </p>
<p>Popular <strong>interceptor tools</strong> like <strong>Burp Suite</strong> and <strong>ZAP</strong> are essentially <strong>proxies with logging and manipulation capabilities</strong>, designed specifically for <strong>testing and security analysis</strong>.</p>
<p>For a little better explanation of proxies, check this out:<br><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/what-is-proxy-server/">What is a Proxy Server?</a></p>
<hr>
<h2 id="Designing-an-HTTP-HTTPS-Interceptor"><a href="#Designing-an-HTTP-HTTPS-Interceptor" class="headerlink" title="Designing an HTTP&#x2F;HTTPS Interceptor"></a>Designing an HTTP&#x2F;HTTPS Interceptor</h2><p>With this understanding of <strong>proxy servers</strong>, I tried to quickly design an <strong>HTTP&#x2F;HTTPS interceptor</strong>.<br>By default, this is going to be <strong>local</strong>, so the <strong>endpoint IP</strong> will be <code>127.0.0.1</code>.</p>
<h3 id="Basic-Plan"><a href="#Basic-Plan" class="headerlink" title="Basic Plan"></a>Basic Plan</h3><ol>
<li>The <strong>HTTP interceptor</strong> will listen on <strong>port 8080</strong>.</li>
<li><strong>Port 8080</strong> will be configured in <strong>Firefox as a proxy server</strong>, forwarding all browser requests to the interceptor.</li>
<li>The <strong>HTTP Interceptor</strong> should <strong>capture requests</strong> from the client and <strong>cache them</strong>.</li>
<li>The <strong>HTTP Interceptor</strong> should <strong>forward the request</strong> and <strong>cache the response</strong> from the server.</li>
<li>The <strong>intercepted data</strong> should be displayed to the user.</li>
</ol>
<p>By just explaining what I’m trying to build, I kinda created <strong>software requirements</strong> 😅.</p>
<p><img src="/Images/Interceptor.png" alt="Proxy Interception Flow"></p>
<hr>
<h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>The above image represents the <strong>high-level design</strong> and plan for the interceptor.<br>At this point, I realized I wouldn’t be able to <strong>intercept HTTPS requests</strong> because that would mean handling <strong>TLS&#x2F;SSL encryption&#x2F;decryption</strong>.<br>(This will be explored in one of the upcoming Saturdays!)</p>
<hr>
<h2 id="Building-the-Interceptor-in-Golang"><a href="#Building-the-Interceptor-in-Golang" class="headerlink" title="Building the Interceptor in Golang"></a>Building the Interceptor in Golang</h2><p>I always wanted to explore <strong>Golang</strong>, so I decided to build this interceptor in Go.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request, interceptedData *[]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, mu *sync.Mutex)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Read the entire request body</span></span><br><span class="line">    body, _ := io.ReadAll(r.Body)</span><br><span class="line">    r.Body.Close() <span class="comment">// Close the request body to free resources</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bypass Firefox captive portal detection by responding with &quot;204 No Content&quot;</span></span><br><span class="line">    <span class="keyword">if</span> r.URL.Host == <span class="string">&quot;detectportal.firefox.com&quot;</span> &#123;</span><br><span class="line">        w.WriteHeader(http.StatusNoContent)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store request details in a map</span></span><br><span class="line">    requestData := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;method&quot;</span>: r.Method,      <span class="comment">// HTTP method (GET, POST, etc.)</span></span><br><span class="line">        <span class="string">&quot;url&quot;</span>:    r.URL.String(), <span class="comment">// Full request URL</span></span><br><span class="line">        <span class="string">&quot;body&quot;</span>:   <span class="type">string</span>(body),  <span class="comment">// Request body as a string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new HTTP request using the extracted method, URL, and body</span></span><br><span class="line">    req, err := http.NewRequest(r.Method, r.URL.String(), bytes.NewReader(body))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, <span class="string">&quot;Failed to create request&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy headers from the original request to the new request</span></span><br><span class="line">    req.Header = r.Header.Clone()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Forward the request to the actual destination</span></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err) <span class="comment">// Log the error</span></span><br><span class="line">        http.Error(w, <span class="string">&quot;Failed to forward request&quot;</span>, http.StatusBadGateway)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close() <span class="comment">// Ensure the response body is closed to prevent resource leaks</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the response body into a byte slice</span></span><br><span class="line">    originalRespBody, _ := io.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a copy of the response body for sending to the browser</span></span><br><span class="line">    respBodyForBrowser := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(originalRespBody))</span><br><span class="line">    <span class="built_in">copy</span>(respBodyForBrowser, originalRespBody)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the response is gzip-compressed and decompress if necessary</span></span><br><span class="line">    <span class="keyword">if</span> resp.Header.Get(<span class="string">&quot;Content-Encoding&quot;</span>) == <span class="string">&quot;gzip&quot;</span> &#123;</span><br><span class="line">        gzipReader, err := gzip.NewReader(bytes.NewReader(originalRespBody))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;Failed to decompress response&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> gzipReader.Close()</span><br><span class="line">        originalRespBody, _ = io.ReadAll(gzipReader) <span class="comment">// Read the decompressed response</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract and print the Content-Type for debugging</span></span><br><span class="line">    contentType := resp.Header.Get(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    fmt.Println(requestData[<span class="string">&quot;url&quot;</span>]) <span class="comment">// Print the request URL</span></span><br><span class="line">    fmt.Println(contentType)        <span class="comment">// Print the response content type</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump the response headers for debugging (excluding the body)</span></span><br><span class="line">    dump, _ := httputil.DumpResponse(resp, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store response details in requestData for logging or interception</span></span><br><span class="line">    requestData[<span class="string">&quot;response&quot;</span>] = html.EscapeString(<span class="type">string</span>(originalRespBody)) <span class="comment">// Escape HTML to prevent script injection</span></span><br><span class="line">    requestData[<span class="string">&quot;headers&quot;</span>] = <span class="type">string</span>(dump) <span class="comment">// Store raw headers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the shared data structure before modifying it (to ensure thread safety)</span></span><br><span class="line">    mu.Lock()</span><br><span class="line">    *interceptedData = <span class="built_in">append</span>(*interceptedData, requestData) <span class="comment">// Save request details</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy response headers to the client response</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> resp.Header &#123;</span><br><span class="line">        <span class="keyword">for</span> _, val := <span class="keyword">range</span> v &#123;</span><br><span class="line">            w.Header().Add(k, val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the original response status code</span></span><br><span class="line">    w.WriteHeader(resp.StatusCode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the response body to the client without modification</span></span><br><span class="line">    w.Write(respBodyForBrowser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>While running, I came across <strong>Firefox’s Captive Portal detection</strong>.<br>A <strong>captive portal</strong> is used in <strong>hotels, cafes, or public Wi-Fi networks</strong> to <strong>authenticate users</strong> before granting internet access.<br>To read more about it: <a target="_blank" rel="noopener" href="https://support.mozilla.org/en-US/kb/captive-portal">Firefox Captive Portal</a>.</p>
<hr>
<h2 id="How-the-Interceptor-Works"><a href="#How-the-Interceptor-Works" class="headerlink" title="How the Interceptor Works"></a>How the Interceptor Works</h2><ol>
<li>The <strong>client (browser) sends a request</strong> → received by the <strong>proxy server (interceptor)</strong>.</li>
<li>The <strong>proxy server creates a copy of the request</strong> and forwards it to the <strong>actual server</strong>.</li>
<li>The <strong>server sends a response</strong> → the <strong>proxy stores it and forwards it back</strong> to the client.</li>
</ol>
<p>Pretty simple! Well… it <strong>seemed simple</strong>, but it certainly took some time to understand <strong>Golang</strong> and its libraries.<br>There were hiccups—like <strong>not realizing the server was encoding responses in Gzip</strong>. I <strong>spent half a day</strong> just figuring out what kind of encoding the server was using when sending responses to the client. 🤦‍♂️</p>
<hr>
<h2 id="Building-the-Viewer"><a href="#Building-the-Viewer" class="headerlink" title="Building the Viewer"></a>Building the Viewer</h2><p>To <strong>view the intercepted data</strong>, I created a <strong>separate HTTP server</strong> running on <strong>port 8081</strong> within the same Golang app.<br>This <strong>Data Viewer</strong> server:</p>
<ul>
<li>Uses the <strong>intercepted data from the proxy server (8080)</strong>.</li>
<li>Serves a <strong>vanilla JavaScript UI</strong> that requests data every second.</li>
<li>Displays the <strong>intercepted requests and responses</strong> dynamically.</li>
</ul>
<p><img src="/Images/NodeApp.png" alt="Node App"><br><img src="/Images/HTTPInterception.gif" alt="GIF of Intercepted Requests"></p>
<hr>
<h2 id="Wrapping-Up"><a href="#Wrapping-Up" class="headerlink" title="Wrapping Up"></a>Wrapping Up</h2><p>Though I didn’t cover all the code in this blog, you can find it on my <strong><a target="_blank" rel="noopener" href="https://github.com/vijayanathan23/HTTPInterceptor">https://github.com/vijayanathan23/HTTPInterceptor</a></strong>.</p>
<p>Thanks for reading from <strong>TheSaturdayProjects</strong> 🤖!</p>

    </div>
</article>

    </main>

    <footer>
        <p>Made with ❤️ by TheSaturdayProjects<!-- | <a class="button-coffee" href="https://www.buymeacoffee.com/yourusername" target="_blank">Buy me a coffee</a></p>-->
    </footer>
</body>
</html>
